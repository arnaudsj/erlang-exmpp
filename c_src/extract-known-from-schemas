#!/usr/bin/perl
# $Id$

use strict;
use warnings;
use utf8;

use LWP::UserAgent;
use URI::WithBase;
use POSIX qw(strftime);

use Data::Dumper;
$Data::Dumper::Indent = 1;

sub main {
	my ($nss_fn, $names_fn, $attrs_fn) = @_;

	unless (defined $nss_fn && defined $names_fn && defined $attrs_fn) {
		print STDERR "Usage: $0 <nss_fn> <names_fn> <attrs_fn>\n";
		return (1);
	}

	open(NSS,   ">$nss_fn");
	open(NAMES, ">$names_fn");
	open(ATTRS, ">$attrs_fn");

	# Prepare timestamp.
	my $now = strftime "%Y-%m-%dT%H:%M:%SZ", gmtime;

	# Print header.
	my $header =<< "EOF";
# \$Id\$
# $now
EOF
	print NSS $header;
	print NAMES $header;
	print ATTRS $header;

	my $title;
	my $ns;
	my $home;

	my $ua = LWP::UserAgent->new;

	while (<STDIN>) {
		my $line = $_;
		my $url;
		my $content;
		my $last_modified;
		my $req;
		my $res;

		# Skip empty lines.
		next if $line =~ /^\s*$/;

		# Interpret special comments; skip others.
		if ($line =~ /^# XEP: (.+)$/) {
			$title = $1;
			next;
		} elsif ($line =~ /^# NS: (.+)$/) {
			$ns = $1;
			next;
		} elsif ($line =~ /^# HOME: (.+)$/) {
			$home = $1;
			next;
		} elsif ($line =~ /^\s*#/) {
			next;
		} else {
			$url = $line;
			chomp $url;
		}

		if (defined $title && defined $ns) {
			print STDERR "$title: $ns\n";
		}

		# We first try to extract informations from the schema
		# at the end of the documentation, because it may be
		# more up-to-date than the "real" schema. For instance,
		# this seems to be the case for XEP-0124.

		# Fetch documentation.
		unless ($title =~ /RFC\s+392[01]/) {
			$req = HTTP::Request->new(GET => $home);
			$res = $ua->request($req);
		}
		unless (defined $res && $res->is_success &&
		    $res->content =~ /xs:schema.+targetNamespace/s) {
			# Fetch schema.
			$req = HTTP::Request->new(GET => $url);
			$res = $ua->request($req);
			unless ($res->is_success) {
				print STDERR "Can't retrieve URL '$url'\n";
				next;
			}

			$content = $res->content;
		} else {
			$content = $res->content;
			$last_modified = $res->headers->last_modified;
		}

		# Initialize entry's header.
		$header =<< "EOF";

# --------------------------------------------------------------------
EOF

		# Get description and namespace.
		if (defined $title) {
			$header .= "# XEP: $title\n";
		}
		if (defined $home) {
			$header .= "# HOME: $home\n";
		}
		if (defined $ns) {
			$header .= "# NS: $ns\n";
		}

		$header .= "# SCHEMA: $url\n";

		if (defined $last_modified) {
			my @gmtime = gmtime($last_modified);
			$last_modified = strftime "%Y-%m-%dT%H:%M:%SZ", @gmtime;
			$header .= "# Last-Modified: $last_modified\n";
		}

		print NSS $header;
		print NAMES $header;
		print ATTRS $header;

		# Walk through the lines of $content.
		my %names = ();
		my %attrs = ();
		foreach $line (split /[\r\n]+/, $content) {
			# Retrieve the real namespace.
			if ($line =~ /targetNamespace=['"]([^'"]+)['"]/) {
				print NSS "\n$1\n";
				next;
			}

			if ($line =~ /xs:element\s+name=['"]([^'"]+)['"]/) {
				# Found an element name.
				my $name = $1;
				$names{$name} = 1 unless exists $names{$name};
				next;
			}
			if ($line =~ /xs:attribute\s+name=['"]([^'"]+)['"]/) {
				# Found an attribute name.
				my $attr = $1;
				next if $attr =~ /^xml:/;
				$attrs{$attr} = 1 unless exists $attrs{$attr};
				next;
			}
		}

		if (keys %names) {
			print NAMES "\n".join("\n", sort keys %names), "\n";
		}
		if (keys %attrs) {
			print ATTRS "\n".join("\n", sort keys %attrs), "\n";
		}

		undef $title;
		undef $ns;
		undef $home;
	}

	close(NSS);
	close(NAMES);
	close(ATTRS);
}

main(@ARGV);
